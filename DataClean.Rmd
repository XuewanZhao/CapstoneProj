---
title: "R Notebook"
output: html_notebook
---
Let's see what we need to do.
1. Form a window containing 500 tickers for each quarter.
(To save memory, we can use a function to decide in a certain quarter, 
what's the stock list for SP500.)
2. Manage the IBES forecast feature.
3. Manage CRSP feature and do calculation.
3. Store them and prepare for regression.

```{r}
# options(warn=-1)
library(writexl)
library(readxl)
library(dplyr)
library(reshape2)
library(ggcorrplot)
```

Import datasets.

```{r}
DateRange = readxl::read_excel("D:\\data\\Capstone\\Data\\Valid date range.xlsx")
DateRange$thru[is.na(DateRange$thru)] <- 20190101

CRSP = readxl::read_excel("D:\\data\\Capstone\\Data\\CRSP Features.xlsx")
OHLC = readxl::read_excel("D:\\data\\Capstone\\Data\\OHLC_quarter.xlsx")
LinkKey = readxl::read_excel("D:\\data\\Capstone\\Data\\LK.xlsx")

```

Support Functions.
```{r}
# This function would return the consititute of SP500 with gvkey, ticker and cusip
# during given start date and end date.
SP_constitute = function(start_date,end_date){
  temp = subset(DateRange, (DateRange$from<= start_date)&(DateRange$thru>=end_date), 
select=c(gvkey,co_tic,co_cusip))
  temp
}
#### Test function.
# test = SP_constitute(19950101,19950331)

# This function would be used to transform year,quarter to yyyymmdd format.
TransYQtoDate = function(year,qtr){
  year*10000 + qtr*3*100 + 31
}

# This function would determine the lookback period for a certain quarter.
Lookback = function(year,qtr){
  if(qtr==1){
    c(year-6,4,year-1,4)
  }else{
    c(year-5,qtr-1,year,qtr-1)
  }
}

# Provide corresponding keys from key given.
GVKtoPERMNO = function(GVKEYs,LK){
  NList = subset(LK,(LK$GVKEY %in% GVKEYs),select = c(GVKEY,PERMNO))
  NList
}
#### Test function.
# test1 = pull(LinkKey[sample(nrow(LinkKey[,1]), 10, replace=F),1])
# test2 = GVKtoPERMNO(test1,LinkKey)

# Do linear regression and prediction of the return in next quarter.
LRP = function(df,Pred){
  x = df[1:20,]
  x = x[complete.cases(x),]
  y = df[21,]
  y = y[complete.cases(y),]
  Pred = data.frame(matrix(ncol = 3, nrow = 0))
  names(Pred)<-c("GVKEY","Pred","Actual")
  if((nrow(x)>5)&(nrow(y))){
    ols.fit = lm(formula = RET~MV+DVY+E2PFY0+B2P+S2EV,data = x)
    Pred[1,] = c(y$GVKEY,predict(ols.fit,y),y$RET)
    Pred
  }else{
    Pred[1,] = c(df[1,]$GVKEY,NA,NA)
    Pred
  }
}
#### Test function.
# df = CRSP_cur[CRSP_cur$GVKEY==1177,]
# LRP(df)

# Select out records in certain quarter.
Sub_qtr_rec = function(df,sp500, lkbk,yr,qtr){
  subset(df,(df$GVKEY %in% sp500$gvkey)&(df$DATE>TransYQtoDate(lkbk[1],lkbk[2]))&(df$DATE<=TransYQtoDate(yr,qtr)))
}

# Select out stocks which are included in both feature dataset and return dataset.
Common_stk = function(feature,ret){
  Complete_info = intersect(feature$GVKEY,ret$GVKEY)
  ret = subset(ret,(ret$GVKEY %in% Complete_info))
  feature = subset(feature,(feature$GVKEY %in% Complete_info))
  # Now we need to match the number of records.
  Complete_info_v1 = Complete_info[table(feature$GVKEY)==table(ret$GVKEY)]
  ret = subset(ret,(ret$GVKEY %in% Complete_info_v1))
  feature = subset(feature,(feature$GVKEY %in% Complete_info_v1))
  list(feature,ret)
}

# Given the aim quarter of features, calculate the aim quarter of return.
QFtoQR = function(fyr,fqtr){
  test_y_r = fyr + floor((fqtr+3)/5)
  test_q_r = if(fqtr==1) 4 else ((fqtr+3)%%4)
  c(test_y_r,test_q_r)
}
```

Variable statistics.

```{r}
# Plot the correlation heat map for fundamental factors.
cormat = round(cor(subset(CRSP,select=c(MV,EV,DVY,EBITDA2EV,E2PFY0,B2P,S2EV)),use="complete.obs"),2)

melted_cormat = melt(cormat)
jpeg("CorHeatMap.jpg")
ggcorrplot(cormat,hc.order=TRUE,type="upper",lab=TRUE)
dev.off()

CRSP_v1 = subset(CRSP,select=c(MV,EV,DVY,EBITDA2EV,E2PFY0,B2P,S2EV))
# Now we examine the properties of selected features.
##### NA values in each feature
na_count = data.frame(sapply(CRSP_v1, function(y)
sum(length(which(is.na(y))))))/nrow(CRSP_v1)
names(na_count) = c("NA")

# Plot histogram of NA values in column "P/E Ratio" in all the sheet_s elements
jpeg("NA in factors.jpg",width = 600)
barplot(t(na_count))
dev.off()

# Final Subset to screen the stocks with 5 selected features.
CRSP_F = subset(CRSP,select=c(GVKEY,DATE,MV,DVY,E2PFY0,B2P,S2EV))
```

Main function for fundamental factor stock selection.

```{r}
# Main function:
#   Given a certain quarter for features, this function would return the prediction of stock return in corresponding quarter (2 quarters' later), with lookback period as 20 quarters.
Feature_Pred = function(test_y_f,test_q_f){
  test_r = QFtoQR(test_y_f,test_q_f)
  
  #### 1. Select out stocks available during certain period.
  lkbk_f = Lookback(test_y_f,test_q_f)
  lkbk_r = Lookback(test_r[1],test_r[2])
  SP500_list_gvkey = SP_constitute(TransYQtoDate(lkbk_f[1],lkbk_f[2]),TransYQtoDate(test_r[1],test_r[2]))
  
  #### 2. Select out and match the CRSP data and return of stocks from OHLC.
  CRSP_cur = Sub_qtr_rec(CRSP_F,SP500_list_gvkey,lkbk_f,test_y_f,test_q_f)
  OHLC_cur = Sub_qtr_rec(OHLC,SP500_list_gvkey,lkbk_r,test_r[1],test_r[2])
  
  #### 3. Then we could merge these two dataframes.
  # Firstly select out available stocks in each dataset.
  fea_ret = Common_stk(CRSP_cur,OHLC_cur)
  # Sort the records and then add them into one single dataframe.
  OHLC_cur = fea_ret[[2]][with(fea_ret[[2]], order(GVKEY, ym)),]
  CRSP_cur = fea_ret[[1]][with(fea_ret[[1]], order(GVKEY, DATE)),]
  CRSP_cur$RET = OHLC_cur$RET
  
  #### 4. We backtest each stock and predict the performance of next period.
  
  Pred = CRSP_cur %>%
    group_by(GVKEY) %>%
    do(LRP(.))
  
  # Now we get the prediction of return in next quarter and actual return.
  # Thus we can evaluate the performance of our model.
  Pred
}

#### Test our function.
# test_y_f = 2003
# test_q_f = 3
# 
# temp = Feature_Pred(test_y_f,test_q_f)

# Valuation function.
#   As we could have the prediction and actual returns from our main function, Feature_Pred, we want to examine the performance of our model. Here we would use 2 methods:
#     1. MSE of prediction and actual return.
#     2. Performance of selected stocks according to prediction and the equally weighted benchmark portfolio.
Valuation = function(df){
  mse = mean((df$Pred - df$Actual)^2,na.rm = TRUE)
  r2 = 1-mse/mean((df$Actual - mean(df$Actual,na.rm = TRUE))^2,
                  na.rm=TRUE)
  temp = df[complete.cases(df),]
  temp = temp[with(temp,order(Pred)),]
  # Equally weighted investment return.
  benchmark = mean(temp$Actual)
  n = as.integer(nrow(temp)*0.2)
  mdl = mean(tail(temp,n)$Actual) - mean(head(temp,n)$Actual)
  c(mse,r2,benchmark,mdl)
}

```

Rolling screening and evaluate the performance of our linear model.

```{r}
# Check if there is 500 stocks in each quarter.
years = c(1998:2018)
qtrs = c(1:4)
last_ = 19980101
StockNum = data.frame(yr = integer(),
                      qtr = integer(),
                      num = integer())
for(y in years){
  for(q in qtrs){
    cur_ = TransYQtoDate(y,q)
    const_ = SP_constitute(last_,cur_)
    StockNum[nrow(StockNum)+1,] = list(y,q,nrow(const_))
    last_ = cur_
  }
}
jpeg("Num of SP500.jpg")
plot(StockNum$yr+0.25*StockNum$qtr,StockNum$num,main="Number of stocks in SP500", xlab="Time", ylab="# of stocks")

# Now we could test our model, and store the results.
res = data.frame(yr = integer(), qtr = integer(),
                 MSE = numeric(), R2 = numeric(),
                 BMK = numeric(), MDL = numeric())

yrs = c(2003:2018)
for(y in yrs){
  for(q in qtrs){
    Pred_yq = Feature_Pred(y,q)
    res_yq = Valuation(Pred_yq)
    res[nrow(res)+1,] = c(y,q,res_yq)
  }
}

```























Data Clean Part.

# Data clean process for CRSP
```{r}
# In this part, we input the CRSP quarterly data and reform them into features.
CRSP_ori = readxl::read_excel("D:\\data\\Capstone\\Data\\CRSP Quarterly data.xlsx")

CRSP_feature = subset(CRSP_ori,select=c(GVKEY,datadate,fyearq,fqtr))

CRSP_feature$MV = CRSP_ori$cshoq*CRSP_ori$prccq

CRSP_feature$EV = CRSP_feature$MV + CRSP_ori$dlcq + CRSP_ori$dlttq + CRSP_ori$pstkq - CRSP_ori$cheq

CRSP_feature$tax_rate = CRSP_ori$txtq/CRSP_ori$piq

CRSP_ori$CFO = c(NA,diff(CRSP_ori$oancfy, lag=1))
CRSP_feature$CFO2EV = CRSP_ori$CFO + (CRSP_ori$xintq*(1-CRSP_feature$tax_rate))

CRSP_ori$ASSETS = CRSP_ori$ceqq + CRSP_ori$dlcq + CRSP_ori$dlttq + CRSP_ori$pstkq - CRSP_ori$cheq
CRSP_feature$RONA = (CRSP_ori$ibq+(CRSP_ori$xintq*(1-CRSP_feature$tax_rate)))/CRSP_ori$ASSETS

CRSP_ori$EBITDA = CRSP_ori$saleq - CRSP_ori$cogsq - CRSP_ori$xsgaq
CRSP_feature$EBITDA2EV = CRSP_ori$EBITDA/CRSP_feature$EV

CRSP_feature$E2PFY0 = CRSP_ori$ibcomq/CRSP_feature$MV

CRSP_feature$BB2P = (CRSP_ori$dvy + CRSP_ori$prstkcy-CRSP_ori$sstky)/CRSP_feature$MV

CRSP_ori$EQ_REPO = CRSP_ori$prstkcy - CRSP_ori$sstky
CRSP_ori$DEBT_REPO = CRSP_ori$dltry - CRSP_ori$dlcchy - CRSP_ori$dltisy
CRSP_feature$BB2EV = (CRSP_ori$dvy + CRSP_ori$EQ_REPO - CRSP_ori$DEBT_REPO)/CRSP_feature$EV

CRSP_feature$B2P = CRSP_ori$ceqq/CRSP_feature$MV

CRSP_feature$S2EV = CRSP_ori$saleq/CRSP_feature$EV

CRSP_feature$DVY = CRSP_ori$dvy

CRSP_feature$DATE = TransYQtoDate(CRSP_feature$fyearq,CRSP_feature$fqtr)

# We save the features thus we don't need to recalculate it everytime.
writexl::write_xlsx(CRSP_feature, path="D:\\data\\Capstone\\Data\\CRSP Features.xlsx", col_names=TRUE)
```
# Data clean process for OHLC
```{r}
# Now we prepare the OHLC prices for these stocks.
OHLC_ori = readxl::read_excel("D:\\data\\Capstone\\Data\\OHLCV_v1.xlsx")
temp = as.character(OHLC_ori$DATE)
OHLC_ori$month = as.numeric(substr(temp, start=5,stop=6))
OHLC_ori$day = as.numeric(substr(temp, start=7,stop=8))

OHLC_v1 = subset(OHLC_ori, (OHLC_ori$month %in% c(3,6,9,12))&(OHLC_ori$day>=28))

# Now we wish to pick out the last valid record in 3,6,9,12 month.
OHLC_v1$ym = substr(as.character(OHLC_v1$DATE), start=1,stop=6)

OHLC_final = OHLC_v1 %>%
  group_by(PERMNO) %>%
  group_by(ym) %>%
  top_n(-1,day)

OHLC_final = OHLC_final %>%
  group_by(GVKEY) %>%
  mutate(RET = (c(CLOSE[-(seq(1))], rep(NA, 1))/CLOSE - 1))

# We save the results thus we don't need to recalculate it everytime.
writexl::write_xlsx(OHLC_final, path="D:\\data\\Capstone\\Data\\OHLC_quarter.xlsx", col_names=TRUE)
```
# Data clean process for LinkKey
```{r}
LinkKey = readxl::read_excel("D:\\data\\Capstone\\Data\\LinkKey_v2.xlsx")
LK_v1 = distinct(subset(LinkKey, select=c(gvkey,tic,cusip,LPERMNO)))
names(LK_v1)[names(LK_v1) == 'LPERMNO'] = 'PERMNO'
names(LK_v1)[names(LK_v1) == 'gvkey'] = 'GVKEY'
# We save the results thus we don't need to recalculate it everytime.
writexl::write_xlsx(LK_v1, path="D:\\data\\Capstone\\Data\\LK.xlsx", col_names=TRUE)
```